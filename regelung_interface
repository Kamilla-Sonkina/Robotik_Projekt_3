class RegelungsInterface:
    def __init__(self):
        self._robot_pos = {'x': None, 'y': None, 'z': None}
        self._object_pos = {'x': None, 'y': None}
        self._velocity = None
        self._object_class = None
        self._target_position = {'x': None, 'y': None, 'z': None}
        self._gripper_is_activated = False

    # Getter and setter methods for encapsulated attributes
    def get_robot_pos(self):
        return self._robot_pos
    
    def set_robot_pos(self, pos):
        self._robot_pos = pos

    def get_object_pos(self):
        return self._object_pos
    
    def set_object_pos(self, pos):
        self._object_pos = pos

    def get_velocity(self):
        return self._velocity
    
    def set_velocity(self, velocity):
        self._velocity = velocity

    def get_object_class(self):
        return self._object_class
    
    def set_object_class(self, object_class):
        self._object_class = object_class

    def get_target_position(self):
        return self._target_position
    
    def set_target_position(self, target_pos):
        self._target_position = target_pos

    def get_gripper_is_activated(self):
        return self._gripper_is_activated
    
    def set_gripper_is_activated(self, activated):
        self._gripper_is_activated = activated



import rclpy
from rclpy.node import Node
from ro45_portalrobot_interfaces.msg import RobotPos, RobotCmd
from object_interfaces.msg import ObjectData
from std_msgs.msg import Float64, String
import time
import asyncio

class RegelungsNode(Node):
    MOVING_STATE = "MovingState"
    OVER_BOX_STATE = "OverBoxState"
    DEFAULT_STATE = "DefaultState"
    PICK_UP_READY_STATE = "PickUpReadyState"

    def __init__(self):
        super().__init__('regelungs_node')

        self.arm_positions_sub = self.create_subscription(RobotPos, 'robot_arm_position', self.arm_position_callback, 10)
        self.object_data_sub = self.create_subscription(ObjectData, 'object_data', self.object_data_callback, 10)
        self.vel_sub = self.create_subscription(Float64, 'velocity', self.velocity_callback, 10)
        self.robot_command_pub = self.create_publisher(RobotCmd, 'robot_arm_commands', 10)

        # Initialize robot positions, object data, etc.
        self.robot_pos = {'x': None, 'y': None, 'z': None}
        self.object_data = {'x': None, 'y': None, 'class': None, 'timestamp': None, 'index': None}
        self.oldest_object = {'x': None, 'y': None, 'class': None, 'timestamp': None, 'index': None}
        self.velocity = None

        self.box_unicorn = {'x': 10, 'y': 11, 'z': 12}
        self.box_cat = {'x': 10, 'y': 11, 'z': 12}
        self.default_pos = {'x': 10, 'y': 11, 'z': 12}
        self.safe_pos = {'x': 10, 'y': 11, 'z': 12}
        self.pick_up_z = 13
        self.gripper_is_activated = False
        self.target_position = {'x': None, 'y': None, 'z': None}

        # Initialize controller parameters
        self.last_calculation_time = time.time()
        self.last_error_x = 0
        self.last_error_y = 0
        self.last_error_z = 0
        self.kp = 9.85199  
        self.kd = 6.447857  
        self.kn = 50
        self.velo_zaehler = 0
        self.queue = []

        # Initiaal state 
        self.state = self.MOVING_STATE  

    async def go_to_target_position(self):
        while True:
            if self.state == self.MOVING_STATE:
                while abs(self.target_position - self.robot_pos) >= 0.5:
                    self.regler()
                    await asyncio.sleep(0.1)

                if abs(self.target_position - self.box_cat) >= 0.5 or abs(self.target_position - self.box_unicorn) >= 0.5:
                    self.gripper_is_activated = False
                    self.regler()
                    self.state = self.OVER_BOX_STATE
                elif abs(self.target_position - self.default_pos) >= 0.5:
                    await asyncio.sleep(5)  # Placeholder action, waiting for 5 seconds
                    self.state = self.DEFAULT_STATE
                else:
                    if abs(self.robot_pos['z'] - self.pick_up_z) >= 0.5:
                        self.gripper_is_activated = True
                        self.regler()
                        self.sort(self.oldest_object['class'])
                    else:
                        self.robot_pos['z'] = self.pick_up_z
                        self.regler()
                        self.calculate_target_position()
                    self.state = self.MOVING_STATE

            elif self.state == self.OVER_BOX_STATE:
                # Move to default position after being over the box
                self.gripper_is_activated = False
                self.regler()
                self.go_to_target_position(self.default_pos)
                self.state = self.DEFAULT_STATE

            elif self.state == self.DEFAULT_STATE:
                # Wait for a certain period of time
                await asyncio.sleep(5)
                self.state = self.PICK_UP_READY_STATE

            elif self.state == self.PICK_UP_READY_STATE:
                # Prepare to pick up an object
                if abs(self.robot_pos['z'] - self.pick_up_z) >= 0.5:
                    self.gripper_is_activated = True
                    self.regler()
                    self.sort(self.oldest_object['class'])
                else:
                    self.robot_pos['z'] = self.pick_up_z
                    self.regler()
                    self.calculate_target_position()
                self.state = self.MOVING_STATE

    def arm_position_callback(self, msg):
        self.robot_pos['x'] = msg.pos_x
        self.robot_pos['y'] = msg.pos_y
        self.robot_pos['z'] = msg.pos_z
        self.regler()

    def object_data_callback(self, msg):
        self.object_data['x'] = msg.pos_x
        self.object_data['y'] = msg.pos_y
        self.object_data['class'] = msg.object_class
        self.object_data['timestamp'] = msg.timestamp_value
        self.object_data['index'] = msg.index_value
        self.enqueue(self.object_data)

    def velocity_callback(self, msg):
        if self.velo_zaehler != 0:
            self.velocity = (self.velocity / self.velo_zaehler + msg.data / self.velo_zaehler) / self.velo_zaehler + 1
        else: 
            self.velocity = msg.data
        self.velo_zaehler += 1

    def calculate_target_position(self):
        if self.gripper_is_activated:
            if self.oldest_object['class'] == 'cat':
                self.target_position = self.box_cat
            elif self.oldest_object['class'] == 'unicorn':
                self.target_position = self.box_unicorn
            else:
                self.target_position = self.default_pos
        
        if len(self.queue) != 0:
            self.target_position['x'] = self.oldest_object['class'] + self.velocity * (time.time() - self.oldest_object['timestamp'])
            self.target_position['y'] = self.oldest_object['class']
            self.target_position['z'] = self.pick_up_z
        else: 
            self.target_position = self.default_pos

    async def go_to_target_position(self, target_pos):
        while abs(self.target_position - self.robot_pos) >= 0.5:
            self.regler()

        if abs(self.target_position - self.box_cat) >= 0.5 or abs(self.target_position - self.box_unicorn) >= 0.5:
            self.gripper_is_activated = False
            self.regler()
            self.go_to_target_position(self.default_pos)
        elif abs(self.target_position - self.default_pos) >= 0.5:
            await asyncio.sleep(5)
        else:
            if abs(self.robot_pos['z'] - self.pick_up_z) >= 0.5:
                self.gripper_is_activated = True
                self.regler()
                self.sort(self.oldest_object['class'])
            else:
                self.robot_pos['z'] = self.pick_up_z
                self.regler()
                self.calculate_target_position()

    def sort(self, oldest_object):
        if self.gripper_is_activated: 
            if oldest_object['class'] == 'cat':
                self.go_to_target_position(self.box_cat)
                self.gripper_is_activated = False
                self.oldest_object = self.dequeue()
            if oldest_object['class'] == 'unicorn':
                self.go_to_target_position(self.box_unicorn)  
                self.gripper_is_activated = False  
                self.oldest_object = self.dequeue()

    def regler(self):
        differenz_x = self.target_position['x'] - self.robot_pos['x']    
        differenz_y = self.target_position['y'] - self.robot_pos['y']  
        differenz_z = self.target_position['z'] - self.robot_pos['z']   
        current_time = time.time()
        dt = current_time - self.last_calculation_time
        self.last_calculation_time = current_time
        vel_x = self.compute_pd(differenz_x, self.last_error_x, dt)
        self.last_error_x = differenz_x
        vel_y = self.compute_pd(differenz_y, self.last_error_y, dt)
        self.last_error_y = differenz_y
        vel_z = self.compute_pd(differenz_z, self.last_error_z, dt)
        self.last_error_z = differenz_z
        robot_cmd = RobotCmd()
        robot_cmd.accel_x = vel_x
        robot_cmd.accel_y = vel_y
        robot_cmd.accel_z = vel_z
        robot_cmd.activate_gripper = self.gripper_is_activated
        self.robot_command_pub.publish(robot_cmd)
        
    def compute_pd(self, error, last_error, dt):
        derivative = (error - last_error) / dt
        control_signal = self.kp * error + self.kd * (self.kn / (1 + self.kn * (1 / dt))) * derivative
        return control_signal

    def enqueue(self, object_data):
        self.queue.append(object_data)
    
    def dequeue(self):
        if len(self.queue) != 0:
            return self.queue.pop(0)


def main(args=None):
    rclpy.init(args=args)
    node = RegelungsNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()

