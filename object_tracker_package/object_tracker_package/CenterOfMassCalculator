import cv2
import numpy as np

class CenterOfMassCalculator:
    def calculate_center_of_mass(self, image, x, y, w, h):
        """
        Berechnet den Schwerpunkt des erkannten Objekts in einem Bild und verschiebt ihn um 5 Pixel in die entgegengesetzte Richtung des geringsten Abstands zum Rand.

        Args:
            image (numpy.ndarray): Das gesamte Bild.
            x (int): Die x-Koordinate des oberen linken Eckpunkts des Begrenzungsrahmens.
            y (int): Die y-Koordinate des oberen linken Eckpunkts des Begrenzungsrahmens.
            w (int): Die Breite des Begrenzungsrahmens.
            h (int): Die Höhe des Begrenzungsrahmens.

        Returns:
            tuple: Die (cx, cy) Koordinaten des verschobenen Schwerpunkts im gesamten Bild.
        """
        object_roi = image[y:y+h, x:x+w]
        gray_roi = cv2.cvtColor(object_roi, cv2.COLOR_BGR2GRAY)
        _, binary_roi = cv2.threshold(gray_roi, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
        
        # Finden der Konturen der Objekte im binären Bild
        contours, _ = cv2.findContours(binary_roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Falls keine Konturen gefunden wurden, gibt es keine Objekte
        if len(contours) == 0:
            return None

        # Finden des größten Objekts basierend auf der Konturfläche
        largest_contour = max(contours, key=cv2.contourArea)

        # Berechnung der Momente des größten Objekts
        moments = cv2.moments(largest_contour)

        # Berechnung des Schwerpunkts (Centroid) des größten Objekts
        if moments['m00'] != 0:
            centroid_x = int(moments['m10'] / moments['m00'])
            centroid_y = int(moments['m01'] / moments['m00'])
            
            # Berechnung der Abstände vom Schwerpunkt zu den Rändern des Objekts
            distances = []
            for point in largest_contour:
                px, py = point[0]
                distance = np.sqrt((px - centroid_x)*2 + (py - centroid_y)*2)
                distances.append((distance, (px, py)))
            
            # Finden des Punktes mit dem geringsten Abstand
            min_distance, min_point = min(distances, key=lambda x: x[0])
            px, py = min_point

            # Richtung des geringsten Abstands bestimmen und den Schwerpunkt verschieben
            dx = centroid_x - px
            dy = centroid_y - py
            distance = np.sqrt(dx*2 + dy*2)
            if distance > 0:
                shift_x = int((dx / distance) * 1)
                shift_y = int((dy / distance) * 1)
                centroid_x += shift_x
                centroid_y += shift_y

            return (centroid_x + x, centroid_y + y)
        else:
            return None
