import cv2
import numpy as np

class CenterOfMassCalculator:
    def calculate_center_of_mass(self, image, x, y, w, h):
        """
        Berechnet den Schwerpunkt des erkannten Objekts in einem Bild und verschiebt ihn um 10 Pixel in die entgegengesetzte Richtung des geringsten Abstands zum Rand.

        Args:
            image (numpy.ndarray): Das gesamte Bild.
            x (int): Die x-Koordinate des oberen linken Eckpunkts des Begrenzungsrahmens.
            y (int): Die y-Koordinate des oberen linken Eckpunkts des Begrenzungsrahmens.
            w (int): Die Breite des Begrenzungsrahmens.
            h (int): Die Höhe des Begrenzungsrahmens.

        Returns:
            tuple: Die (cx, cy) Koordinaten des verschobenen Schwerpunkts im gesamten Bild.
        """
        # ROI ausschneiden
        object_roi = image[y:y+h, x:x+w]
        gray_roi = cv2.cvtColor(object_roi, cv2.COLOR_BGR2GRAY)
        
        # Bild glätten, um Rauschen zu reduzieren
        blurred_roi = cv2.GaussianBlur(gray_roi, (5, 5), 0)
        
        # Fester Schwellenwert
        _, binary_roi = cv2.threshold(blurred_roi, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
    
        # Morphologische Operationen
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
        cleaned = cv2.morphologyEx(binary_roi, cv2.MORPH_CLOSE, kernel, iterations=2)
    
        # Konturen finden
        contours, _ = cv2.findContours(cleaned, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if len(contours) == 0:
            return None
        
        # Momente berechnen
        moments = cv2.moments(cleaned)
        
        # Schwerpunkt berechnen
        if moments["m00"] != 0:
            center_x = int(moments["m10"] / moments["m00"])
            center_y = int(moments["m01"] / moments["m00"])
        else:
            center_x, center_y = 0, 0

        # Berechnen des Schwerpunkts im gesamten Bild
        global_center_x, global_center_y = int(center_x + x), int(center_y + y)

        # Geringsten Abstand zum Rand des Objekts finden
        min_distance = float('inf')
        closest_point = None
        for contour in contours:
            for point in contour:
                px, py = point[0]
                distance = np.sqrt((center_x - px) ** 2 + (center_y - py) ** 2)
                if distance < min_distance:
                    min_distance = distance
                    closest_point = (px, py)

        if closest_point:
            px, py = closest_point
            # Richtung des geringsten Abstands bestimmen
            dx = center_x - px
            dy = center_y - py
            distance = np.sqrt(dx ** 2 + dy ** 2)
            if distance > 0:
                # Verschieben des Schwerpunkts in die entgegengesetzte Richtung um 10 Pixel
                shift_x = int((dx / distance) * 10)
                shift_y = int((dy / distance) * 10)
                shifted_center_x = center_x + shift_x
                shifted_center_y = center_y + shift_y
                # Berechnen des verschobenen Schwerpunkts im gesamten Bild
                global_shifted_center_x, global_shifted_center_y = int(shifted_center_x + x), int(shifted_center_y + y)
                return (global_shifted_center_x, global_shifted_center_y)
        
        return (global_center_x, global_center_y)
