import rclpy
from rclpy.node import Node
from object_interfaces.msg import ObjectData  # Import the ObjectData message
import cv2
import numpy as np

class KameraPublisher(Node):
    def __init__(self):
        super().__init__('kamera_publisher')
        self.object_data_pub = self.create_publisher(ObjectData, 'object_data', 10)
        self.cap = cv2.VideoCapture(0)

        self.src_points = np.float32([[415, 735], [1510, 760], [405, 975], [1500, 960]])
        self.dst_points = np.float32([[415, 735], [1500, 735], [415, 975], [1500, 975]])

        if not self.cap.isOpened():
            self.get_logger().error("Error: Could not open video.")
            rclpy.shutdown()
            return

        self.timer = self.create_timer(0.1, self.timer_callback)
        self.previous_position = None
        self.previous_time = self.get_clock().now()

    def transform_perspective(self, frame, src_points, dst_points):
        print(f"Source points: {src_points}")  
        print(f"Destination points: {dst_points}")  
        matrix = cv2.getPerspectiveTransform(src_points, dst_points)
        result_frame = cv2.warpPerspective(frame, matrix, (frame.shape[1], frame.shape[0]))
        return result_frame

    def draw_coordinate_system(self, frame, origin, x_axis_point):
        print(f"Origin: {origin}, X-axis point: {x_axis_point}")  
        frame_with_coordinate_system = frame.copy()
        cv2.arrowedLine(frame_with_coordinate_system, origin, x_axis_point, (0, 0, 255), 2)
        cv2.arrowedLine(frame_with_coordinate_system, origin, (origin[0], 735), (0, 0, 255), 2)
        cv2.putText(frame_with_coordinate_system, '0', (origin[0] + 10, origin[1] + 10), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
        cv2.putText(frame_with_coordinate_system, 'X', (x_axis_point[0] - 20, x_axis_point[1] + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
        cv2.putText(frame_with_coordinate_system, 'Y', (origin[0] + 10, 750), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)
        return frame_with_coordinate_system

    def timer_callback(self):
        ret, frame = self.cap.read()
        if not ret:
            self.get_logger().info("Video capture failed or ended, shutting down node.")
            rclpy.shutdown()
            return

        transformed_frame = self.transform_perspective(frame, self.src_points, self.dst_points)
        frame_with_coordinate_system = self.draw_coordinate_system(transformed_frame, (415, 975), (1500, 975))
        frame_with_coordinate_system = cv2.cvtColor(frame_with_coordinate_system, cv2.COLOR_RGB2BGR)

        hsv = cv2.cvtColor(frame_with_coordinate_system, cv2.COLOR_BGR2HSV)
        lower_white = np.array([0, 0, 100])
        upper_white = np.array([180, 50, 255])
        mask = cv2.inRange(hsv, lower_white, upper_white)
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        print(f"Contours found: {len(contours)}")  

        object_position = None
        object_class = "object"  # Placeholder for object class
        index_value = 1  # Placeholder for index value

        if len(contours) > 0:
            for contour in contours:
                x, y, w, h = cv2.boundingRect(contour)
                print(f"Bounding rect: x={x}, y={y}, w={w}, h={h}")  # Debug print
                
                # Drawing rectangles 
                cv2.rectangle(frame_with_coordinate_system, (x, y), (x + w, y + h), (0, 255, 0), 2)
                relative_position = (x - 415, 975 - y)
                print(f"Relative position: {relative_position}")  # Debug print
                cv2.putText(frame_with_coordinate_system, f'Relative Position: {relative_position}', (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 2)
                object_position = relative_position  

        if object_position:
            pos_x = float(object_position[0])
            pos_y = float(object_position[1])
            timestamp = self.get_clock().now().nanoseconds / 1e9  #nanoseconds to seconds

            # Geschwindigkeit
            current_time = self.get_clock().now()
            velocity = 0.0
            if self.previous_position is not None:
                time_delta = (current_time - self.previous_time).nanoseconds / 1e9  # nanoseconds to seconds
                if time_delta > 0:
                    velocity = np.linalg.norm(np.array(object_position) - np.array(self.previous_position)) / time_delta
                print(f"Velocity: {velocity}")  

            # Publish object data
            object_data = ObjectData()
            object_data.pos_x = pos_x
            object_data.pos_y = pos_y
            object_data.object_class = object_class
            object_data.timestamp_value = timestamp
            object_data.index_value = index_value
            object_data.velocity = velocity
            self.object_data_pub.publish(object_data)

            self.previous_position = object_position
            self.previous_time = current_time

        cv2.imshow("Transformed Frame with Object Detection", frame_with_coordinate_system)
        key = cv2.waitKey(1)
        if key == ord('q'):
            self.get_logger().info("Exit signal received, shutting down node.")
            self.cap.release()
            cv2.destroyAllWindows()
            rclpy.shutdown()

def main(args=None):
    rclpy.init(args=args)
    kamera_publisher = KameraPublisher()
    rclpy.spin(kamera_publisher)
    kamera_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
